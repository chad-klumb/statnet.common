% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rle_utils.R
\name{rle-op}
\alias{rle-op}
\alias{!.rle}
\alias{binop.rle}
\alias{|.rle}
\alias{&.rle}
\alias{*.rle}
\alias{/.rle}
\alias{-.rle}
\alias{+.rle}
\alias{^.rle}
\alias{\%\%.rle}
\alias{\%/\%.rle}
\alias{==.rle}
\alias{>.rle}
\alias{<.rle}
\alias{!=.rle}
\alias{<=.rle}
\alias{>=.rle}
\title{Unary and binary operations}
\usage{
\method{!}{rle}(x)

binop.rle(e1, e2, FUN)

\method{|}{rle}(e1, e2)

\method{&}{rle}(e1, e2)

\method{*}{rle}(e1, e2)

\method{/}{rle}(e1, e2)

\method{-}{rle}(e1, e2)

\method{+}{rle}(e1, e2)

\method{^}{rle}(e1, e2)

\method{\%\%}{rle}(e1, e2)

\method{\%/\%}{rle}(e1, e2)

\method{==}{rle}(e1, e2)

\method{>}{rle}(e1, e2)

\method{<}{rle}(e1, e2)

\method{!=}{rle}(e1, e2)

\method{<=}{rle}(e1, e2)

\method{>=}{rle}(e1, e2)
}
\arguments{
\item{x, e1, e2}{Arguments to unary (\code{x}) and binary (\code{e1} and \code{e2})
operators.}

\item{FUN}{A binary function or operator or a name of one. It is
assumed to be vectorized: it expects two vectors of equal length
and outputs a vector of the same length.}
}
\value{
Unless otherwise stated, all functions return an \code{\link{rle}}
object. By default, the functions and the operators do not merge
adjacent runs with the same value. This must be done explicitly
with \code{\link{compact}}.
}
\description{
The following unary and binary operations are implemented at this
time, returning an \code{\link{rle}} object.
}
\section{Functions}{
\itemize{
\item \code{binop.rle}: Perform an arbitrary binary operation on the pair of vectors
represented by the \code{\link{rle}} objects.
}}

\examples{

x <- rle(as.logical(rbinom(10,1,.7)))
y <- rle(as.logical(rbinom(10,1,.3)))

stopifnot(isTRUE(all.equal((!inverse.rle(x)),inverse.rle(!x))))
stopifnot(isTRUE(all.equal((inverse.rle(x)|inverse.rle(y)),inverse.rle(x|y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)&inverse.rle(y)),inverse.rle(x&y))))

x <- rle(sample(c(-1,+1), 10, c(.7,.3), replace=TRUE))
y <- rle(sample(c(-1,+1), 10, c(.3,.7), replace=TRUE))

stopifnot(isTRUE(all.equal((inverse.rle(x)*inverse.rle(y)),inverse.rle(x*y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)/inverse.rle(y)),inverse.rle(x/y))))
stopifnot(isTRUE(all.equal((-inverse.rle(y)),inverse.rle(-y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)-inverse.rle(y)),inverse.rle(x-y))))
stopifnot(isTRUE(all.equal((+inverse.rle(y)),inverse.rle(+y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)+inverse.rle(y)),inverse.rle(x+y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)^inverse.rle(y)),inverse.rle(x^y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)\%\%inverse.rle(y)),inverse.rle(x\%\%y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)\%/\%inverse.rle(y)),inverse.rle(x\%/\%y))))
stopifnot(isTRUE(all.equal(inverse.rle(x)==inverse.rle(y),inverse.rle(x==y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)>inverse.rle(y)),inverse.rle(x>y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)<inverse.rle(y)),inverse.rle(x<y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)!=inverse.rle(y)),inverse.rle(x!=y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)<=inverse.rle(y)),inverse.rle(x<=y))))
stopifnot(isTRUE(all.equal((inverse.rle(x)>=inverse.rle(y)),inverse.rle(x>=y))))
}
